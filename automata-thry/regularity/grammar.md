a grammar is defined by a quadruple $G = \set{V, T, S, P}$ where:
- $V$ is a finite set of objects called **variables**, 
- $T$ is the set of **terminals**, 
- $S$ is the **start variable**
- $P$ is the set of **productions**, 

$V$ and $T$ are always non-empty and disjoint.

production rules always takes the form:
$$x\rightarrow y$$
where $x \in (V\cup T)^+$, and $y \in (V\cup T)^*$. This means to **replace** $x$ with $y$ to get a new string.

$L(G)$ is called the **language** generated by the grammar, or $\set{w \in T^{*}: s \Rightarrow^{*} w}$ (the set of all possible strings on $T^{*}$ such that they are derived from $S$ by using the grammar $G$.)

The final string resulted by performing all the grammatical operations should **not** contain a variable in them. That means that, to be a valid grammar, all $v \in V$ should be able to produce a string, or another variable that produces a string.

Consider a language $G$ where 
- $S \rightarrow SS$
- $S \rightarrow \lambda$
- $S \rightarrow aSb$
- $S \rightarrow bSa$

then, the language $L(G$) will take the notation: $L(G) = \set{w: n_{a}(w)= n_{b}(w)}$, or "**all strings w such that the number of a's is equal to the number of b's**"

## proofs
example: prove that all strings derived from G must have a's == b's

proof 1: from grammar to language: 
- any string derived from $S$ has the same amount of a's as b's
- thus, all strings derived from $G$ has the required property,

proof 2: proof that all strings in the language is derived from G. since this is tricky, we have to use **strong induction**:
- base case: $S\rightarrow \lambda$
- assume that every string of length $2n$ can be derived from G. 
$\rightarrow$ we have to prove that every string of length $2n + 2$ can be derived from G. 

## right linear / left linear grammars
a right linear grammar is a grammar where the variables always appear to the right of the terminal symbol, and for example, can be defined as: 
- $A \rightarrow xB$
- $A \rightarrow x$

while a left linear grammar is a grammar where the variables always appear to the left of the terminal symbol (in this case, $x$). as an example, it can look like: 
- $A \rightarrow Bx$
- $B \rightarrow x$

> a language is a regular language if an only if it has a RLG or a LFG.

knowing this, we can essentially translate these transitions into a dfa.
### conversions
#### from right linear language transitions to a [nfa](finite%20automata.md)
1. for every variable, find the string needed for it to go to another variable.
2. if the string is more than 1 character long, chain it through another node
3. if the variable goes to a terminal symbol, send it to the accept state

#### from a regexp to a language
1. convert it into an nfa
2. derive the left/right linear language as needed